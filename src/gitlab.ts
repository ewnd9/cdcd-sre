import axios from 'axios';

import fs from 'fs/promises';
import { env } from './config';
import { logger } from './logger';
import { GitLabWebhookBody } from './types';

const client = axios.create({
  baseURL: env.GITLAB_HOST,
  headers: {
    'PRIVATE-TOKEN': env.GITLAB_TOKEN,
  },
});

export async function processWebhook(body: GitLabWebhookBody) {
  const {
    project_id: projectId,
    build_id: id,
    build_name: name,
    build_status: status,
    build_duration: duration,
    build_allow_failure: isFailureAllowed,
    repository: { git_http_url: repoUrlWithGitSuffix },
  } = body;

  if (process.env.WRITE_REQUESTS) {
    await fs.writeFile(
      `data/job-${id}-${status}.json`,
      JSON.stringify(body, null, 2)
    );
  }

  const job = {
    projectId,
    id,
    name,
    status,
    duration,
    isFailureAllowed,
    url: `${repoUrlWithGitSuffix.replace('.git', '')}/-/jobs/${id}`,
    logs: '',
  };

  if (status === 'failed') {
    job.logs = await getLogs({ projectId, jobId: job.id });
  }

  return job;
}

type UpsertCommentResult = 'created' | 'updated' | 'empty-message' | 'no-mr';
export async function upsertComment({
  id,
  projectId,
  refName,
  sha,
  buildMessage,
}: {
  id: string;
  projectId: number;
  refName: string;
  sha: string;
  buildMessage: (opts: { mrId: string; isNew: boolean }) => string | null | Promise<string | null>;
}): Promise<UpsertCommentResult> {
  const { data } = await client.get(`/api/v4/projects/${projectId}/merge_requests`, {
    params: { state: 'opened', source_branch: refName },
  });

  if (!data[0]) {
    logger.error(`no mr for ${projectId}, branch - ${refName}`);
    return 'no-mr';
  }

  const mrId = data[0].iid;
  const { data: comments } = await client.get(
    `/api/v4/projects/${projectId}/merge_requests/${mrId}/notes`,
    {
      params: {
        sort: 'asc',
      },
    },
  );

  const marker = `<!--cicd-sre(id=${id})-->`;
  const existingComment = comments.find(comment => comment.body.includes(marker));
  const isNew = !existingComment;

  const rawMessage = await buildMessage({ mrId, isNew });
  if (rawMessage === null) {
    return 'empty-message';
  }

  const message = [rawMessage, `Generated by \`cicd-sre\` against ${sha}`, marker].join('\n\n');

  if (isNew) {
    const { data } = await client.post(
      `/api/v4/projects/${projectId}/merge_requests/${mrId}/notes`,
      {
        body: message,
      },
    );

    logger.info(data);
    return 'created';
  } else {
    const { data } = await client.put(
      `/api/v4/projects/${projectId}/merge_requests/${mrId}/notes/${existingComment.id
      }`,
      {
        body: message,
      },
    );

    logger.info(data);
    return 'updated';
  }
}


export async function getLogs({ projectId, jobId }) {
  const { data } = await client.get<string>(
    `/api/v4/projects/${encodeURIComponent(projectId)}/jobs/${jobId}/trace`,
    {
      headers: {
        // code: 'Z_BUF_ERROR' on trying to decode brottli
        'Accept-Encoding': 'gzip',
      },
    }
  );

  return data;
}
